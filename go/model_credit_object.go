/*
Lago API documentation

Lago API allows your application to push customer information and metrics (events) from your application to the billing application.

API version: 0.52.0-beta
Contact: tech@getlago.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package lagoapi

import (
	"encoding/json"
	"fmt"
)

// checks if the CreditObject type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &CreditObject{}

// CreditObject struct for CreditObject
type CreditObject struct {
	// Unique identifier assigned to the credit within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the creditâ€™s item record within the Lago system.
	LagoId string `json:"lago_id"`
	// The amount of credit associated with the invoice, expressed in cents.
	AmountCents int32 `json:"amount_cents"`
	AmountCurrency Currency `json:"amount_currency"`
	// Indicates whether the credit is applied on the amount before taxes (coupons) or after taxes (credit notes). This flag helps determine the order in which credits are applied to the invoice calculation
	BeforeTaxes bool `json:"before_taxes"`
	Item CreditObjectItem `json:"item"`
	Invoice CreditObjectInvoice `json:"invoice"`
}

type _CreditObject CreditObject

// NewCreditObject instantiates a new CreditObject object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewCreditObject(lagoId string, amountCents int32, amountCurrency Currency, beforeTaxes bool, item CreditObjectItem, invoice CreditObjectInvoice) *CreditObject {
	this := CreditObject{}
	this.LagoId = lagoId
	this.AmountCents = amountCents
	this.AmountCurrency = amountCurrency
	this.BeforeTaxes = beforeTaxes
	this.Item = item
	this.Invoice = invoice
	return &this
}

// NewCreditObjectWithDefaults instantiates a new CreditObject object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewCreditObjectWithDefaults() *CreditObject {
	this := CreditObject{}
	return &this
}

// GetLagoId returns the LagoId field value
func (o *CreditObject) GetLagoId() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.LagoId
}

// GetLagoIdOk returns a tuple with the LagoId field value
// and a boolean to check if the value has been set.
func (o *CreditObject) GetLagoIdOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.LagoId, true
}

// SetLagoId sets field value
func (o *CreditObject) SetLagoId(v string) {
	o.LagoId = v
}

// GetAmountCents returns the AmountCents field value
func (o *CreditObject) GetAmountCents() int32 {
	if o == nil {
		var ret int32
		return ret
	}

	return o.AmountCents
}

// GetAmountCentsOk returns a tuple with the AmountCents field value
// and a boolean to check if the value has been set.
func (o *CreditObject) GetAmountCentsOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return &o.AmountCents, true
}

// SetAmountCents sets field value
func (o *CreditObject) SetAmountCents(v int32) {
	o.AmountCents = v
}

// GetAmountCurrency returns the AmountCurrency field value
func (o *CreditObject) GetAmountCurrency() Currency {
	if o == nil {
		var ret Currency
		return ret
	}

	return o.AmountCurrency
}

// GetAmountCurrencyOk returns a tuple with the AmountCurrency field value
// and a boolean to check if the value has been set.
func (o *CreditObject) GetAmountCurrencyOk() (*Currency, bool) {
	if o == nil {
		return nil, false
	}
	return &o.AmountCurrency, true
}

// SetAmountCurrency sets field value
func (o *CreditObject) SetAmountCurrency(v Currency) {
	o.AmountCurrency = v
}

// GetBeforeTaxes returns the BeforeTaxes field value
func (o *CreditObject) GetBeforeTaxes() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.BeforeTaxes
}

// GetBeforeTaxesOk returns a tuple with the BeforeTaxes field value
// and a boolean to check if the value has been set.
func (o *CreditObject) GetBeforeTaxesOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.BeforeTaxes, true
}

// SetBeforeTaxes sets field value
func (o *CreditObject) SetBeforeTaxes(v bool) {
	o.BeforeTaxes = v
}

// GetItem returns the Item field value
func (o *CreditObject) GetItem() CreditObjectItem {
	if o == nil {
		var ret CreditObjectItem
		return ret
	}

	return o.Item
}

// GetItemOk returns a tuple with the Item field value
// and a boolean to check if the value has been set.
func (o *CreditObject) GetItemOk() (*CreditObjectItem, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Item, true
}

// SetItem sets field value
func (o *CreditObject) SetItem(v CreditObjectItem) {
	o.Item = v
}

// GetInvoice returns the Invoice field value
func (o *CreditObject) GetInvoice() CreditObjectInvoice {
	if o == nil {
		var ret CreditObjectInvoice
		return ret
	}

	return o.Invoice
}

// GetInvoiceOk returns a tuple with the Invoice field value
// and a boolean to check if the value has been set.
func (o *CreditObject) GetInvoiceOk() (*CreditObjectInvoice, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Invoice, true
}

// SetInvoice sets field value
func (o *CreditObject) SetInvoice(v CreditObjectInvoice) {
	o.Invoice = v
}

func (o CreditObject) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o CreditObject) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["lago_id"] = o.LagoId
	toSerialize["amount_cents"] = o.AmountCents
	toSerialize["amount_currency"] = o.AmountCurrency
	toSerialize["before_taxes"] = o.BeforeTaxes
	toSerialize["item"] = o.Item
	toSerialize["invoice"] = o.Invoice
	return toSerialize, nil
}

func (o *CreditObject) UnmarshalJSON(bytes []byte) (err error) {
    // This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"lago_id",
		"amount_cents",
		"amount_currency",
		"before_taxes",
		"item",
		"invoice",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(bytes, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varCreditObject := _CreditObject{}

	err = json.Unmarshal(bytes, &varCreditObject)

	if err != nil {
		return err
	}

	*o = CreditObject(varCreditObject)

	return err
}

type NullableCreditObject struct {
	value *CreditObject
	isSet bool
}

func (v NullableCreditObject) Get() *CreditObject {
	return v.value
}

func (v *NullableCreditObject) Set(val *CreditObject) {
	v.value = val
	v.isSet = true
}

func (v NullableCreditObject) IsSet() bool {
	return v.isSet
}

func (v *NullableCreditObject) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableCreditObject(val *CreditObject) *NullableCreditObject {
	return &NullableCreditObject{value: val, isSet: true}
}

func (v NullableCreditObject) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableCreditObject) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


