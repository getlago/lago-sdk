/*
Lago API documentation

Lago API allows your application to push customer information and metrics (events) from your application to the billing application.

API version: 0.52.0-beta
Contact: tech@getlago.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package lagoapi

import (
	"encoding/json"
	"fmt"
)

// checks if the BillableMetricCreateInputBillableMetric type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &BillableMetricCreateInputBillableMetric{}

// BillableMetricCreateInputBillableMetric struct for BillableMetricCreateInputBillableMetric
type BillableMetricCreateInputBillableMetric struct {
	// Name of the billable metric.
	Name string `json:"name"`
	// Unique code used to identify the billable metric associated with the API request. This code associates each event with the correct metric.
	Code string `json:"code"`
	// Internal description of the billable metric.
	Description NullableString `json:"description,omitempty"`
	// Defines if the billable metric is persisted billing period over billing period.  - If set to `true`: the accumulated number of units calculated from the previous billing period is persisted to the next billing period. - If set to `false`: the accumulated number of units is reset to 0 at the end of the billing period. - If not defined in the request, default value is `false`.
	Recurring *bool `json:"recurring,omitempty"`
	// Property of the billable metric used for aggregating usage data. This field is not required for `count_agg`.
	FieldName NullableString `json:"field_name,omitempty"`
	// Aggregation method used to compute usage for this billable metric.
	AggregationType string `json:"aggregation_type"`
	// Parameter exclusively utilized in conjunction with the `weighted_sum` aggregation type. It serves to adjust the aggregation result by assigning weights and proration to the result based on time intervals. When this field is not provided, the default time interval is assumed to be in `seconds`.
	WeightedInterval NullableString `json:"weighted_interval,omitempty"`
	Group *BillableMetricGroup `json:"group,omitempty"`
}

type _BillableMetricCreateInputBillableMetric BillableMetricCreateInputBillableMetric

// NewBillableMetricCreateInputBillableMetric instantiates a new BillableMetricCreateInputBillableMetric object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewBillableMetricCreateInputBillableMetric(name string, code string, aggregationType string) *BillableMetricCreateInputBillableMetric {
	this := BillableMetricCreateInputBillableMetric{}
	this.Name = name
	this.Code = code
	this.AggregationType = aggregationType
	return &this
}

// NewBillableMetricCreateInputBillableMetricWithDefaults instantiates a new BillableMetricCreateInputBillableMetric object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewBillableMetricCreateInputBillableMetricWithDefaults() *BillableMetricCreateInputBillableMetric {
	this := BillableMetricCreateInputBillableMetric{}
	return &this
}

// GetName returns the Name field value
func (o *BillableMetricCreateInputBillableMetric) GetName() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Name
}

// GetNameOk returns a tuple with the Name field value
// and a boolean to check if the value has been set.
func (o *BillableMetricCreateInputBillableMetric) GetNameOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Name, true
}

// SetName sets field value
func (o *BillableMetricCreateInputBillableMetric) SetName(v string) {
	o.Name = v
}

// GetCode returns the Code field value
func (o *BillableMetricCreateInputBillableMetric) GetCode() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Code
}

// GetCodeOk returns a tuple with the Code field value
// and a boolean to check if the value has been set.
func (o *BillableMetricCreateInputBillableMetric) GetCodeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Code, true
}

// SetCode sets field value
func (o *BillableMetricCreateInputBillableMetric) SetCode(v string) {
	o.Code = v
}

// GetDescription returns the Description field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *BillableMetricCreateInputBillableMetric) GetDescription() string {
	if o == nil || IsNil(o.Description.Get()) {
		var ret string
		return ret
	}
	return *o.Description.Get()
}

// GetDescriptionOk returns a tuple with the Description field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *BillableMetricCreateInputBillableMetric) GetDescriptionOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Description.Get(), o.Description.IsSet()
}

// HasDescription returns a boolean if a field has been set.
func (o *BillableMetricCreateInputBillableMetric) HasDescription() bool {
	if o != nil && o.Description.IsSet() {
		return true
	}

	return false
}

// SetDescription gets a reference to the given NullableString and assigns it to the Description field.
func (o *BillableMetricCreateInputBillableMetric) SetDescription(v string) {
	o.Description.Set(&v)
}
// SetDescriptionNil sets the value for Description to be an explicit nil
func (o *BillableMetricCreateInputBillableMetric) SetDescriptionNil() {
	o.Description.Set(nil)
}

// UnsetDescription ensures that no value is present for Description, not even an explicit nil
func (o *BillableMetricCreateInputBillableMetric) UnsetDescription() {
	o.Description.Unset()
}

// GetRecurring returns the Recurring field value if set, zero value otherwise.
func (o *BillableMetricCreateInputBillableMetric) GetRecurring() bool {
	if o == nil || IsNil(o.Recurring) {
		var ret bool
		return ret
	}
	return *o.Recurring
}

// GetRecurringOk returns a tuple with the Recurring field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *BillableMetricCreateInputBillableMetric) GetRecurringOk() (*bool, bool) {
	if o == nil || IsNil(o.Recurring) {
		return nil, false
	}
	return o.Recurring, true
}

// HasRecurring returns a boolean if a field has been set.
func (o *BillableMetricCreateInputBillableMetric) HasRecurring() bool {
	if o != nil && !IsNil(o.Recurring) {
		return true
	}

	return false
}

// SetRecurring gets a reference to the given bool and assigns it to the Recurring field.
func (o *BillableMetricCreateInputBillableMetric) SetRecurring(v bool) {
	o.Recurring = &v
}

// GetFieldName returns the FieldName field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *BillableMetricCreateInputBillableMetric) GetFieldName() string {
	if o == nil || IsNil(o.FieldName.Get()) {
		var ret string
		return ret
	}
	return *o.FieldName.Get()
}

// GetFieldNameOk returns a tuple with the FieldName field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *BillableMetricCreateInputBillableMetric) GetFieldNameOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.FieldName.Get(), o.FieldName.IsSet()
}

// HasFieldName returns a boolean if a field has been set.
func (o *BillableMetricCreateInputBillableMetric) HasFieldName() bool {
	if o != nil && o.FieldName.IsSet() {
		return true
	}

	return false
}

// SetFieldName gets a reference to the given NullableString and assigns it to the FieldName field.
func (o *BillableMetricCreateInputBillableMetric) SetFieldName(v string) {
	o.FieldName.Set(&v)
}
// SetFieldNameNil sets the value for FieldName to be an explicit nil
func (o *BillableMetricCreateInputBillableMetric) SetFieldNameNil() {
	o.FieldName.Set(nil)
}

// UnsetFieldName ensures that no value is present for FieldName, not even an explicit nil
func (o *BillableMetricCreateInputBillableMetric) UnsetFieldName() {
	o.FieldName.Unset()
}

// GetAggregationType returns the AggregationType field value
func (o *BillableMetricCreateInputBillableMetric) GetAggregationType() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.AggregationType
}

// GetAggregationTypeOk returns a tuple with the AggregationType field value
// and a boolean to check if the value has been set.
func (o *BillableMetricCreateInputBillableMetric) GetAggregationTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.AggregationType, true
}

// SetAggregationType sets field value
func (o *BillableMetricCreateInputBillableMetric) SetAggregationType(v string) {
	o.AggregationType = v
}

// GetWeightedInterval returns the WeightedInterval field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *BillableMetricCreateInputBillableMetric) GetWeightedInterval() string {
	if o == nil || IsNil(o.WeightedInterval.Get()) {
		var ret string
		return ret
	}
	return *o.WeightedInterval.Get()
}

// GetWeightedIntervalOk returns a tuple with the WeightedInterval field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *BillableMetricCreateInputBillableMetric) GetWeightedIntervalOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.WeightedInterval.Get(), o.WeightedInterval.IsSet()
}

// HasWeightedInterval returns a boolean if a field has been set.
func (o *BillableMetricCreateInputBillableMetric) HasWeightedInterval() bool {
	if o != nil && o.WeightedInterval.IsSet() {
		return true
	}

	return false
}

// SetWeightedInterval gets a reference to the given NullableString and assigns it to the WeightedInterval field.
func (o *BillableMetricCreateInputBillableMetric) SetWeightedInterval(v string) {
	o.WeightedInterval.Set(&v)
}
// SetWeightedIntervalNil sets the value for WeightedInterval to be an explicit nil
func (o *BillableMetricCreateInputBillableMetric) SetWeightedIntervalNil() {
	o.WeightedInterval.Set(nil)
}

// UnsetWeightedInterval ensures that no value is present for WeightedInterval, not even an explicit nil
func (o *BillableMetricCreateInputBillableMetric) UnsetWeightedInterval() {
	o.WeightedInterval.Unset()
}

// GetGroup returns the Group field value if set, zero value otherwise.
func (o *BillableMetricCreateInputBillableMetric) GetGroup() BillableMetricGroup {
	if o == nil || IsNil(o.Group) {
		var ret BillableMetricGroup
		return ret
	}
	return *o.Group
}

// GetGroupOk returns a tuple with the Group field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *BillableMetricCreateInputBillableMetric) GetGroupOk() (*BillableMetricGroup, bool) {
	if o == nil || IsNil(o.Group) {
		return nil, false
	}
	return o.Group, true
}

// HasGroup returns a boolean if a field has been set.
func (o *BillableMetricCreateInputBillableMetric) HasGroup() bool {
	if o != nil && !IsNil(o.Group) {
		return true
	}

	return false
}

// SetGroup gets a reference to the given BillableMetricGroup and assigns it to the Group field.
func (o *BillableMetricCreateInputBillableMetric) SetGroup(v BillableMetricGroup) {
	o.Group = &v
}

func (o BillableMetricCreateInputBillableMetric) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o BillableMetricCreateInputBillableMetric) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["name"] = o.Name
	toSerialize["code"] = o.Code
	if o.Description.IsSet() {
		toSerialize["description"] = o.Description.Get()
	}
	if !IsNil(o.Recurring) {
		toSerialize["recurring"] = o.Recurring
	}
	if o.FieldName.IsSet() {
		toSerialize["field_name"] = o.FieldName.Get()
	}
	toSerialize["aggregation_type"] = o.AggregationType
	if o.WeightedInterval.IsSet() {
		toSerialize["weighted_interval"] = o.WeightedInterval.Get()
	}
	if !IsNil(o.Group) {
		toSerialize["group"] = o.Group
	}
	return toSerialize, nil
}

func (o *BillableMetricCreateInputBillableMetric) UnmarshalJSON(bytes []byte) (err error) {
    // This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"name",
		"code",
		"aggregation_type",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(bytes, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varBillableMetricCreateInputBillableMetric := _BillableMetricCreateInputBillableMetric{}

	err = json.Unmarshal(bytes, &varBillableMetricCreateInputBillableMetric)

	if err != nil {
		return err
	}

	*o = BillableMetricCreateInputBillableMetric(varBillableMetricCreateInputBillableMetric)

	return err
}

type NullableBillableMetricCreateInputBillableMetric struct {
	value *BillableMetricCreateInputBillableMetric
	isSet bool
}

func (v NullableBillableMetricCreateInputBillableMetric) Get() *BillableMetricCreateInputBillableMetric {
	return v.value
}

func (v *NullableBillableMetricCreateInputBillableMetric) Set(val *BillableMetricCreateInputBillableMetric) {
	v.value = val
	v.isSet = true
}

func (v NullableBillableMetricCreateInputBillableMetric) IsSet() bool {
	return v.isSet
}

func (v *NullableBillableMetricCreateInputBillableMetric) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableBillableMetricCreateInputBillableMetric(val *BillableMetricCreateInputBillableMetric) *NullableBillableMetricCreateInputBillableMetric {
	return &NullableBillableMetricCreateInputBillableMetric{value: val, isSet: true}
}

func (v NullableBillableMetricCreateInputBillableMetric) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableBillableMetricCreateInputBillableMetric) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


