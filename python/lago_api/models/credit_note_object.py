# coding: utf-8

"""
    Lago API documentation

    Lago API allows your application to push customer information and metrics (events) from your application to the billing application.

    The version of the OpenAPI document: 0.52.0-beta
    Contact: tech@getlago.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date, datetime
from typing import Any, ClassVar, Dict, List, Optional, Union
from pydantic import BaseModel, StrictFloat, StrictInt, StrictStr, field_validator
from pydantic import Field
from lago_api.models.credit_note_applied_tax_object import CreditNoteAppliedTaxObject
from lago_api.models.credit_note_item_object import CreditNoteItemObject
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class CreditNoteObject(BaseModel):
    """
    CreditNoteObject
    """ # noqa: E501
    lago_id: StrictStr = Field(description="The credit note unique identifier, created by Lago.")
    sequential_id: StrictInt = Field(description="The sequential identifier of the credit note, specifically scoped on the associated invoice. It provides a unique numerical identifier for the credit note within the context of the invoice.")
    number: StrictStr = Field(description="The credit note unique number.")
    lago_invoice_id: StrictStr = Field(description="Unique identifier assigned to the invoice that the credit note belongs to")
    invoice_number: StrictStr = Field(description="The invoice unique number, related to the credit note.")
    issuing_date: date = Field(description="The date of creation of the credit note. It follows the ISO 8601 date format and provides the specific date when the credit note was created.")
    credit_status: Optional[StrictStr] = Field(default=None, description="The status of the credit portion of the credit note. It indicates the current state or condition of the credit amount associated with the credit note. The possible values for this field are:  - `available`: this status indicates that an amount remains available for future usage. The credit can be applied towards future transactions or invoices. - `consumed`: this status indicates that the credit amount has been fully consumed. The remaining amount is 0, indicating that the credit has been utilized in its entirety. - `voided`: this status indicates that the remaining amount of the credit cannot be used any further. The credit has been voided and is no longer available for application or redemption.")
    refund_status: Optional[StrictStr] = Field(default=None, description="The status of the refund portion of the credit note. It indicates the current state or condition of the refund associated with the credit note. The possible values for this field are:  - `pending`: this status indicates that the refund is pending execution. The refund request has been initiated but has not been processed or completed yet. - `succeeded`: this status indicates that the refund has been successfully executed. The refund amount has been processed and returned to the customer or the designated recipient. - `failed`: this status indicates that the refund failed to execute. The refund request encountered an error or unsuccessful processing, and the refund amount could not be returned.")
    reason: StrictStr = Field(description="The reason of the credit note creation. Possible values are `duplicated_charge`, `product_unsatisfactory`, `order_change`, `order_cancellation`, `fraudulent_charge` or `other`.")
    description: Optional[StrictStr] = Field(default=None, description="The description of the credit note.")
    currency: Any
    total_amount_cents: StrictInt = Field(description="The total amount of the credit note, expressed in cents.")
    taxes_amount_cents: StrictInt = Field(description="The tax amount of the credit note, expressed in cents.")
    taxes_rate: Union[StrictFloat, StrictInt] = Field(description="The tax rate associated with this specific credit note.")
    sub_total_excluding_taxes_amount_cents: StrictInt = Field(description="The subtotal of the credit note excluding any applicable taxes, expressed in cents.")
    balance_amount_cents: StrictInt = Field(description="The remaining credit note amount, expressed in cents.")
    credit_amount_cents: StrictInt = Field(description="The credited amount of the credit note, expressed in cents.")
    refund_amount_cents: StrictInt = Field(description="The refunded amount of the credit note, expressed in cents.")
    coupons_adjustment_amount_cents: StrictInt = Field(description="The pro-rated amount of the coupons applied to the source invoice.")
    created_at: datetime = Field(description="The date when the credit note was created. It is expressed in Coordinated Universal Time (UTC).")
    updated_at: datetime = Field(description="The date when the credit note was last updated. It is expressed in Coordinated Universal Time (UTC).")
    file_url: Optional[StrictStr] = Field(default=None, description="The PDF file of the credit note.")
    items: Optional[List[CreditNoteItemObject]] = Field(default=None, description="Array of credit noteâ€™s items.")
    applied_taxes: Optional[List[CreditNoteAppliedTaxObject]] = None
    __properties: ClassVar[List[str]] = ["lago_id", "sequential_id", "number", "lago_invoice_id", "invoice_number", "issuing_date", "credit_status", "refund_status", "reason", "description", "currency", "total_amount_cents", "taxes_amount_cents", "taxes_rate", "sub_total_excluding_taxes_amount_cents", "balance_amount_cents", "credit_amount_cents", "refund_amount_cents", "coupons_adjustment_amount_cents", "created_at", "updated_at", "file_url", "items", "applied_taxes"]

    @field_validator('credit_status')
    def credit_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('available', 'consumed', 'voided'):
            raise ValueError("must be one of enum values ('available', 'consumed', 'voided')")
        return value

    @field_validator('refund_status')
    def refund_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('pending', 'succeeded', 'failed'):
            raise ValueError("must be one of enum values ('pending', 'succeeded', 'failed')")
        return value

    @field_validator('reason')
    def reason_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ('duplicated_charge', 'product_unsatisfactory', 'order_change', 'order_cancellation', 'fraudulent_charge', 'other'):
            raise ValueError("must be one of enum values ('duplicated_charge', 'product_unsatisfactory', 'order_change', 'order_cancellation', 'fraudulent_charge', 'other')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of CreditNoteObject from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of currency
        if self.currency:
            _dict['currency'] = self.currency.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in items (list)
        _items = []
        if self.items:
            for _item in self.items:
                if _item:
                    _items.append(_item.to_dict())
            _dict['items'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in applied_taxes (list)
        _items = []
        if self.applied_taxes:
            for _item in self.applied_taxes:
                if _item:
                    _items.append(_item.to_dict())
            _dict['applied_taxes'] = _items
        # set to None if credit_status (nullable) is None
        # and model_fields_set contains the field
        if self.credit_status is None and "credit_status" in self.model_fields_set:
            _dict['credit_status'] = None

        # set to None if refund_status (nullable) is None
        # and model_fields_set contains the field
        if self.refund_status is None and "refund_status" in self.model_fields_set:
            _dict['refund_status'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if file_url (nullable) is None
        # and model_fields_set contains the field
        if self.file_url is None and "file_url" in self.model_fields_set:
            _dict['file_url'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of CreditNoteObject from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "lago_id": obj.get("lago_id"),
            "sequential_id": obj.get("sequential_id"),
            "number": obj.get("number"),
            "lago_invoice_id": obj.get("lago_invoice_id"),
            "invoice_number": obj.get("invoice_number"),
            "issuing_date": obj.get("issuing_date"),
            "credit_status": obj.get("credit_status"),
            "refund_status": obj.get("refund_status"),
            "reason": obj.get("reason"),
            "description": obj.get("description"),
            "currency": Currency.from_dict(obj.get("currency")) if obj.get("currency") is not None else None,
            "total_amount_cents": obj.get("total_amount_cents"),
            "taxes_amount_cents": obj.get("taxes_amount_cents"),
            "taxes_rate": obj.get("taxes_rate"),
            "sub_total_excluding_taxes_amount_cents": obj.get("sub_total_excluding_taxes_amount_cents"),
            "balance_amount_cents": obj.get("balance_amount_cents"),
            "credit_amount_cents": obj.get("credit_amount_cents"),
            "refund_amount_cents": obj.get("refund_amount_cents"),
            "coupons_adjustment_amount_cents": obj.get("coupons_adjustment_amount_cents"),
            "created_at": obj.get("created_at"),
            "updated_at": obj.get("updated_at"),
            "file_url": obj.get("file_url"),
            "items": [CreditNoteItemObject.from_dict(_item) for _item in obj.get("items")] if obj.get("items") is not None else None,
            "applied_taxes": [CreditNoteAppliedTaxObject.from_dict(_item) for _item in obj.get("applied_taxes")] if obj.get("applied_taxes") is not None else None
        })
        return _obj


